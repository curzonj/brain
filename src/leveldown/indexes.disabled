interface IndexReducersBase<V> {
  [key: string]: (o: V) => undefined | string | string[];
}
type Indexes<V, IDXS> = { [key in keyof IDXS]: Index<V> };
interface IndexedLevelUp<V, IDXS extends IndexReducersBase<V>>
  extends TypedLevelUp<V> {
  idx: Indexes<V, IDXS>;
}

export function indexed<V, IDXS extends IndexReducersBase<V>>(
  db: TypedLevelUp<V>,
  indexes: IDXS
): IndexedLevelUp<V, IDXS> {
  const newDB = db as IndexedLevelUp<V, IDXS>;
  newDB.idx = {} as Indexes<V, IDXS>;

  for (const k in indexes) {
    const idx = encoding(sublevel(db, `idx-${k}`), { valueEncoding: 'id' });
    newDB.idx[k] = AutoIndex(db, idx, () => [indexes[k]].flat(), {
      multi: true,
    });
  }

  return newDB;
}

const topics = indexed(subTyped<models.Doc>(base, 'topics'), {
  queue: (d: models.Doc) => {
    if (!d.queue) return;
    return d.queue.map(q => [q, d._id].join('!'));
  },
  list: (d: models.Doc) => {
    if (!d.list) return;
    return d.list.filter(l => l.startsWith('/')).map(q => [q, d._id].join('!'));
  },
});

