{"version":3,"sources":["web/comps/menu.tsx","web/comps/elements.tsx","common/errors.ts","common/debug.ts","web/comps/use_async.ts","common/models.ts","common/performance.ts","common/typed_event.ts","common/eachOfLimit.ts","common/content.ts","leveldown/indexing.ts","leveldown/index.ts","common/leveldb.ts","web/utils/data.ts","web/utils/abstract_page.ts","web/comps/topic_page.tsx","web/comps/big_textarea.tsx","web/comps/note_page.tsx","web/comps/login_page.tsx","web/comps/menu_page.tsx","web/comps/search_page.tsx","web/comps/recent_page.tsx","web/comps/scroll.tsx","web/comps/loading_stats.tsx","web/comps/app.tsx","web/serviceWorker.ts","index.tsx","leveldown/wrap_abstract.ts","leveldown/sublevel.ts","leveldown/batch.ts"],"names":["Menu","props","className","children","style","float","to","clear","PageHeader","title","ComplexError","message","details","Error","cause","name","constructor","stack","detailsStack","split","slice","stackMessage","join","captureStackTrace","k","surfaceDetails","lowest","annotateErrors","obj","fn","a","catch","e","catchError","opts","Promise","resolve","then","reportError","err","Object","assign","console","error","log","debug","warning","debugLib","events","network","storage","performance","timing","profiling","uiEvents","trace","useAsync","params","debounceSettings","fuzzy","wait","leading","useState","debounce","cb","state","setState","debouncedFn","previousResultForComparison","result","undefined","useEffect","isActive","cancel","isEqual","deepEqual","getAllRefs","doc","keys","flatMap","key","flat","filter","isRef","l","ref","wrapProfiling","label","enabled","profile","time","ret","profileEnd","timeEnd","window","printTiming","list","getEntriesByName","dir","TypedEvent","listeners","listenersOncer","on","listener","push","dispose","off","once","callbackIndex","indexOf","splice","emit","event","emitBoth","this","forEach","length","toCall","eachOfLimit","limit","all","map","reject","iter","Symbol","iterator","index","running","done","next","value","innerIndex","finally","replenish","topicStartKey","topicEndKey","deriveTitle","n","link","notesSorter","p1","p2","metadata","b","created_at","refSorter","buildBackrefs","v","bucketed","reduce","acc","payload","targetId","topic","bucket","r","idList","id","models","actionOn","src","notes","sort","tasks","sorted","first","find","t","firstAction","appendTaskChain","p","nextAction","nextPayload","orderTaskList","getLastSeq","leveldb","configs","get","updateLevelDB","sourceDb","outerLastSeq","inner","lastSeq","changes","include_docs","since","batch_size","resultLastSeq","last_seq","results","change","i","deleted","topics","del","lastSlashItem","put","write","seq","following","getAllDocs","allDocs","update_seq","startkey","endkey","rows","importTopicsToLevelDB","resultSequence","row","freshIndexes","docId","reverse","ENDstr","Index","base","secondary","indexer","indexDb","getAll","gte","lt","options","indexedKey","originalKey","batches","possiblePuts","indexDelsBatchList","indexPutsBatchList","indexOps","batch","indexBatch","type","indexKey","LevelWrapper","db","indexers","idx","indexed","levelup","sublevel","buildIndexes","sub","delsPossible","values","indexes","updateIndex","updateIndexes","array","end","err2","codeStorageVersion","tokenizer","WordTokenizer","remoteDbMemoized","loading","errorPayload","hasFired","isPending","leveljsStore","leveljs","batched","batching","encoding","valueEncoding","subIndexed","backrefs","terms","text","s","tokenize","toLowerCase","match","uploads","buildLevelDB","getReverseMappings","outbound","d","stale_at","getTopic","topicKey","addNote","topicId","trim","cuid","_id","topicToDocID","Date","now","broader","startsWith","navigator","onLine","remoteDb","getRemoteDb","attemptNoteUpload","at","isConfigured","getDbTarget","info","uploadNotes","initialize","backgroundSync","syncToLevelDB","isStorageSchemaCurrent","schemaCurrent","resetStorageSchema","store","config","PouchDB","url","localStorage","couchdb_target","JSON","parse","auth","status","writeBatch","topicID","NestedSectionListFieldNames","sectionFunctions","buildAbstractPage","progressiveRender","sections","reloadWhenDone","dataLoading","page","buildTasksDiv","maybePayloadsToTextObjects","heading","maybeListDiv","collection","divs","narrower","sectionDoc","topicSection","context","listFieldNameDivs","input","maybeLabelRefs","names","field","Array","isArray","topicToTextObject","maybeAddRefTextObjects","tos","refToTextObject","some","rto","unshift","buildRelatedDivList","quotes","related","links","silencer","maybeResolveSrc","srcNode","TopicPage","textItem","simpleList","item","showMore","buildAnchorElement","search","refLink","stringify","mobile","document","documentElement","clientWidth","target","replace","rel","href","encodeURIComponent","cssClass","encodeURI","BigTextAreaPage","handler","restProps","textValue","setTextValue","onSubmitHandler","preventDefault","onClick","onKeyDown","which","metaKey","shiftKey","autoComplete","autoCapitalize","required","onChange","NotePage","history","LoginPage","loadingBarCss","css","LoginRedirector","withRouter","dbInitialized","setInitialized","dataLoaded","setDataLoaded","location","pathname","widthUnit","width","color","MenuPage","SearchPage","useHistory","useLocation","searchTerm","URLSearchParams","term","onSubmit","placeholder","RecentPage","setResults","ScrollToTopInner","prevProps","scrollTo","React","Component","ScrollToTop","LoadingStats","pastTime","setTimeout","duration","process","isLocalhost","Boolean","hostname","registerValidSW","swUrl","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","ReactDOM","render","basename","from","exact","path","component","getElementById","URL","origin","addEventListener","fetch","response","contentType","headers","ready","unregister","reload","checkValidServiceWorker","WrappedAbstract","handlers","leveldown","open","down","ifOpen","close","operations","AbstractLevelDOWN","Sublevel","prefix","_wrapper","separator","buildPrefix","gt","x","concat","Buffer","isBuffer","ENDbuf","buildWrapper","subdb","xopts","hasOwnProperty","call","isRangeOption","addRestOptions","wrap","start","SubIterator","ite","seek","AbstractIterator","rangeOptions","isLooseAbstract","_db","_batch","_iterator","compatibleConstructor","Batching","ops","nextTick","o","batcher"],"mappings":"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","file":"static/js/main.2a5e7af0.chunk.js","sourcesContent":["import React, { ReactNode } from 'react';\nimport { Link } from 'react-router-dom';\nimport './menu.css';\n\ninterface MenuProps {\n  children: ReactNode;\n}\n\nexport const Menu: React.FC<MenuProps> = props => {\n  return (\n    <div>\n      <ul className=\"menu\">\n        {props.children}\n        <li style={{ float: 'left' }}>\n          <Link to=\"/menu\">menu</Link>\n        </li>\n      </ul>\n      <div style={{ clear: 'both' }}></div>\n    </div>\n  );\n};\n","import React from 'react';\n\nexport function PageHeader(props: { title: string }) {\n  return (\n    <div className=\"header\">\n      <h1 className=\"title\">{props.title}</h1>\n    </div>\n  );\n}\n","export class ComplexError extends Error {\n  details: any;\n  cause?: Error;\n\n  constructor(message: string | Error, details: any = {}) {\n    if (\n      message instanceof Error ||\n      (typeof message !== 'string' && (message as any).message)\n    ) {\n      (details as any).cause = message;\n      message = (details as any).cause.message;\n    }\n\n    super(message as string);\n    // Ensure the name of this error is the same as the class name\n    this.name = this.constructor.name;\n\n    if (details.cause) {\n      this.cause = details.cause;\n      if (details.cause.name) this.name = details.cause.name;\n      delete details.cause;\n    }\n\n    if (details.stack && this.stack) {\n      if (details.stack instanceof Error) {\n        details.stack = details.stack.stack;\n      }\n\n      const detailsStack = details.stack.split('\\n').slice(1);\n      const stackMessage = this.stack.split('\\n')[0];\n      delete details.stack;\n\n      this.stack = [stackMessage, ...detailsStack].join('\\n');\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.details = surfaceDetails(this.cause);\n    for (const k in details) {\n      if (!this.details[k]) this.details[k] = details[k];\n    }\n  }\n}\n\nfunction surfaceDetails(cause: any): object {\n  if (!cause) {\n    return {};\n  }\n\n  const lowest: any = surfaceDetails(cause.cause);\n  if (cause.details) {\n    for (const k in cause.details) {\n      if (!lowest[k]) lowest[k] = cause.details[k];\n    }\n  }\n\n  return lowest;\n}\n\nexport function wrapAsync(fn: () => Promise<void>) {\n  Promise.resolve()\n    .then(fn)\n    .catch(e => {\n      console.error(e);\n    });\n}\n\nexport async function annotateErrors<T>(\n  obj: any,\n  fn: () => Promise<T>\n): Promise<T> {\n  return fn().catch(e => {\n    if (!(e instanceof ComplexError)) {\n      e = new ComplexError(e, obj);\n    }\n\n    throw e;\n  });\n}\n\nexport function catchError(fn: () => any, opts: any = {}) {\n  Promise.resolve()\n    .then(fn)\n    .catch(e => reportError(e, opts));\n}\n\ninterface ErrorFields extends Error {\n  cause?: { stack?: any };\n  details?: any;\n}\nexport function reportError(err: ErrorFields, opts: any = {}) {\n  if (err instanceof ComplexError) {\n    Object.assign(err.details, opts);\n  } else {\n    err = new ComplexError(err, opts);\n  }\n  console.error(err);\n  if (err.cause && err.cause.stack) {\n    console.log(err.cause.stack);\n  }\n  console.log(err.details);\n}\n","import { debug as debugLib } from 'debug';\n\nconst debug = {\n  warning: debugLib('kbase:warning'),\n  events: debugLib('kbase:events'),\n  network: debugLib('kbase:network'),\n  storage: debugLib('kbase:storage'),\n  performance: {\n    timing: debugLib('kbase:performance:timing'),\n    profiling: debugLib('kbase:performance:profiling'),\n  },\n  uiEvents: debugLib('kbase:uievents'),\n  trace: debugLib('kbase:trace'),\n};\n\nexport default debug;\n","import { useEffect, useState } from 'react';\nimport { deepEqual } from 'fast-equals';\nimport { catchError } from '../../common/errors';\nimport { debounce, DebounceSettings } from 'lodash';\nimport debug from '../../common/debug';\n\ninterface AsyncState<T, V> {\n  params?: V;\n  result?: T;\n  fn: (params: V, cb: (result: T | void) => void) => void;\n}\n\nexport interface ExtraOptions {\n  wait: number;\n  fuzzy: boolean;\n}\nexport function useAsync<T, V>(\n  params: V,\n  fn: (params: V, cb: (result: T | void) => void) => Promise<void | T>,\n  debounceSettings: DebounceSettings & ExtraOptions = {\n    fuzzy: false,\n    wait: 200,\n    leading: true,\n  }\n): T | undefined {\n  function inner(params: V, cb: (ret: T | void) => void) {\n    catchError(async () => {\n      cb(await fn(params, cb));\n    });\n  }\n  const { wait, fuzzy } = debounceSettings;\n  const [state, setState] = useState<AsyncState<T, V>>({\n    fn: debounce(inner, wait, debounceSettings),\n  });\n  const debouncedFn = state.fn;\n  const previousResultForComparison = fuzzy ? state.result : undefined;\n\n  useEffect(() => {\n    let isActive = true;\n    (debouncedFn as any).cancel();\n    debouncedFn(params, (result: T | void) => {\n      if (!isActive || !result) return;\n      const isEqual = previousResultForComparison\n        ? deepEqual(result, previousResultForComparison)\n        : false;\n      debug.trace(\n        'useAsync params=%O result=%O changed=%o',\n        params,\n        result,\n        !isEqual\n      );\n      if (isEqual) return;\n      setState({ fn: debouncedFn, params, result });\n    });\n    return () => {\n      isActive = false;\n    };\n  }, [debouncedFn, params, previousResultForComparison]);\n\n  if (fuzzy || state.params === params) return state.result;\n}\n","import PouchDB from 'pouchdb';\n\nexport type Link = string | SearchLink | Ref;\nexport interface SearchLink {\n  search: string;\n}\nexport interface Ref {\n  stale?: boolean;\n  label?: string;\n  ref: string;\n}\n\nexport interface DumbProps {\n  quanity?: string;\n  twitter?: string;\n  date?: string;\n}\nexport interface TopicFields {\n  title?: string;\n  link?: string;\n  aka?: string[];\n  links?: Link[];\n  src?: string | Ref;\n  type?: Ref;\n  text?: string;\n  related?: Ref[];\n  broader?: Ref[];\n  actionOn?: Ref[];\n  narrower?: Ref[];\n  props?: DumbProps;\n}\n\nexport type Topic = TopicFields & {\n  collection?: Ref[];\n};\nexport type TopicKeys = keyof Topic;\n\nexport interface TopicMetadata {\n  id: string;\n  created_at: number;\n  stale_at?: number;\n  nextAction?: Ref;\n  firstAction?: boolean;\n}\n\nexport interface Payload {\n  topic: Topic;\n  metadata: TopicMetadata;\n}\n\nexport type Existing<T = Payload> = PouchDB.Core.ExistingDocument<T>;\nexport type Update<T = Payload> = PouchDB.Core.PutDocument<T> &\n  PouchDB.Core.IdMeta;\nexport type Create<T = Payload> = PouchDB.Core.PutDocument<T>;\nexport type Map<T> = Record<string, T>;\n\nexport function getAllRefs<T extends TopicFields>(\n  doc: T,\n  excludeDeprecated: boolean = false\n): Ref[] {\n  return Object.keys(doc).flatMap(key => {\n    const item = (doc as any)[key];\n    //if (excludeDeprecated && [].indexOf(key) > -1) return [];\n    return [item].flat().filter(isRef);\n  });\n}\n\nexport function uniqueRefs(list: Ref[]): Ref[] {\n  const hash: Record<string, Ref> = list.reduce(\n    (acc, ref) => {\n      acc[ref.ref] = ref;\n      return acc;\n    },\n    {} as Record<string, Ref>\n  );\n\n  return Object.values(hash);\n}\n\nexport function isRef(l: any): l is Ref {\n  if (l === undefined) return false;\n  if (typeof l === 'string') return false;\n  return typeof (l as Ref).ref === 'string';\n}\n\nexport function hasRef(\n  list: undefined | Payload[] | Ref[],\n  r: Payload | Ref | string\n): boolean {\n  if (!list) return false;\n  const idList: string[] = (list as (Payload | Ref)[]).map((l: Payload | Ref) =>\n    isRef(l) ? l.ref : l.metadata.id\n  );\n  const id: string = isRef(r)\n    ? r.ref\n    : typeof r === 'string'\n    ? r\n    : r.metadata.id;\n  return idList.indexOf(id) > -1;\n}\n","import debug from './debug';\nimport { reportError } from './errors';\n\nexport function printTiming() {\n  const list = performance.getEntriesByName('measure');\n  console.dir(list);\n}\n(window as any).printTiming = printTiming;\n\n// WARNING this function uses global labels and is not safe\n// for concurrency.\n// This can be wrapped around high frequency function calls\n// and it will log function calls that take longer than the\n// threshold\nexport async function wrapTiming<T>(\n  label: string,\n  threshold: number,\n  fn: () => Promise<T>\n): Promise<T> {\n  if (!debug.performance.timing.enabled) return fn();\n\n  const start = `${label}-start`;\n  const end = `${label}-end`;\n\n  performance.mark(start);\n\n  const ret = await fn();\n\n  try {\n    performance.mark(end);\n    performance.measure(label, start, end);\n    performance.clearMarks(start);\n    performance.clearMarks(end);\n\n    const list = performance.getEntriesByName(label, 'measure');\n    for (let m of list) {\n      if (m.duration > threshold) {\n        debug.performance.timing('%s %O', label, m);\n      }\n    }\n    performance.clearMeasures(label);\n  } catch (e) {\n    reportError(e);\n  }\n\n  return ret;\n}\n\n// WARNING each profile is a bit expensive, only\n// wrap this around functions called once or twice per page load\nexport async function wrapProfiling<T>(\n  label: string,\n  fn: () => Promise<T>\n): Promise<T> {\n  if (!debug.performance.profiling.enabled) return fn();\n\n  if (console.profile) {\n    console.profile(label);\n  } else if (console.time) {\n    console.time(label);\n  }\n\n  const ret = await fn();\n\n  if (console.profileEnd) {\n    console.profileEnd(label);\n  } else if (console.timeEnd) {\n    console.timeEnd(label);\n  }\n\n  return ret;\n}\n","import debug from './debug';\n\nexport interface Listener<T> {\n  (err: Error | undefined, event: T | undefined): void;\n}\n\nexport interface Disposable {\n  dispose(): void;\n}\n\nexport class Rendezvous<T> {\n  name: string;\n  private payload?: T;\n  private errorPayload?: Error;\n  private event: TypedEvent<T> = new TypedEvent();\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  hasFired = (): boolean =>\n    this.payload !== undefined || this.errorPayload !== undefined;\n  isPending = () => !this.hasFired();\n\n  once = (listener: Listener<T>): void => {\n    if (this.hasFired()) return listener(this.errorPayload, this.payload);\n    this.event.once(listener);\n  };\n\n  then = async <R>(fn: (v: unknown) => R | PromiseLike<R>): Promise<R> => {\n    return new Promise((resolve, reject) => {\n      this.once((err, payload) => (err ? reject(err) : resolve(payload)));\n    }).then(fn);\n  };\n\n  error = (err: Error) => {\n    if (this.hasFired()) throw new Error('Rendezvous already fired');\n\n    this.errorPayload = err;\n    this.event.error(err);\n  };\n\n  done = (payload: T) => {\n    if (this.hasFired()) throw new Error('Rendezvous already fired');\n    debug.events('eventFired name=%s payload=%O', this.name, payload);\n\n    this.payload = payload;\n    this.event.emit(payload);\n  };\n}\n\n/** passes through events as they happen. You will not get events from before you start listening */\nexport class TypedEvent<T> {\n  private listeners: Listener<T>[] = [];\n  private listenersOncer: Listener<T>[] = [];\n\n  on = (listener: Listener<T>): Disposable => {\n    this.listeners.push(listener);\n    return {\n      dispose: () => this.off(listener),\n    };\n  };\n\n  once = (listener: Listener<T>): void => {\n    this.listenersOncer.push(listener);\n  };\n\n  off = (listener: Listener<T>) => {\n    var callbackIndex = this.listeners.indexOf(listener);\n    if (callbackIndex > -1) this.listeners.splice(callbackIndex, 1);\n  };\n\n  emit = (event: T) => this.emitBoth(undefined, event);\n  error = (err: Error) => this.emitBoth(err, undefined);\n\n  private emitBoth(err: Error | undefined, event: T | undefined) {\n    /** Update any general listeners */\n    this.listeners.forEach(listener => listener(err, event));\n\n    /** Clear the `once` queue */\n    if (this.listenersOncer.length > 0) {\n      const toCall = this.listenersOncer;\n      this.listenersOncer = [];\n      toCall.forEach(listener => listener(err, event));\n    }\n  }\n}\n","// TODO implement eachOfLimit\nimport { catchError } from './errors';\nimport debug from './debug';\n\nexport async function eachOfLimit<T>(\n  list: T[],\n  limit: number,\n  fn: (t: T, i: number, l: T[]) => Promise<void>\n): Promise<void> {\n  await Promise.all(list.map(fn));\n\n  await new Promise((resolve, reject) => {\n    const iter = list[Symbol.iterator]();\n    let index = 0;\n    let running = 0;\n    //let runningList: T[] = [];\n    let done = false;\n\n    function next() {\n      const { value, done: iterDone } = iter.next();\n      if (iterDone) {\n        done = true;\n        if (running <= 0) resolve();\n        return;\n      }\n      const innerIndex = index + 1;\n      index += 1;\n\n      running += 1;\n      //runningList.push(value);\n      catchError(async () =>\n        fn(value, innerIndex, list)\n          .finally(() => {\n            running -= 1;\n            //runningList = runningList.filter(i => i !== value);\n          })\n          .then(() => {\n            replenish();\n          })\n          .catch((err: any) => {\n            done = true;\n            reject(err);\n          })\n      );\n    }\n\n    function replenish() {\n      while (running < limit && !done) {\n        next();\n      }\n      /*debug.trace(\n        'eachOfLimit.replenish running=%s done=%s running=%O',\n        running,\n        done,\n        runningList\n      );*/\n\n      if (done && running <= 0) resolve();\n    }\n\n    replenish();\n  });\n}\n","import * as models from './models';\nimport { ComplexError } from './errors';\nimport { LevelDB } from './leveldb';\n//import { eachOfLimit } from 'async';\nimport { eachOfLimit } from './eachOfLimit';\nimport debug from './debug';\nimport { reportError } from './errors';\n\nconst topicStartKey = '$/topics/';\nconst topicEndKey = '$/topics/\\ufff0';\n\nexport function deriveTitle(n: models.Topic): string {\n  if (!n) return 'Missing Page';\n  return n.title || n.link || 'Note';\n}\n\nexport function notesSorter(\n  p1: models.Payload,\n  p2: models.Payload\n): -1 | 0 | 1 {\n  const { metadata: a } = p1;\n  const { metadata: b } = p2;\n  if (!a || !a.created_at || !b || !b.created_at) {\n    debug.warning(\"invalid payloads: %O %O\", p1, p2);\n    return 0;\n  }\n  if (a.created_at > b.created_at) return -1;\n  if (a.created_at < b.created_at) return 1;\n  return 0;\n}\n\ninterface PartialRef {\n  ref?: string;\n}\nexport function refSorter(a: PartialRef, b: PartialRef): number {\n  if (!a.ref) return -1;\n  if (!b.ref) return 1;\n  if (a.ref < b.ref) return -1;\n  if (a.ref > b.ref) return 1;\n  return 0;\n}\n\nexport interface Backrefs {\n  notes?: models.Payload[];\n  backrefs?: models.Payload[];\n  quotes?: models.Payload[];\n  tasks?: models.Payload[];\n}\nexport type BackrefKey = keyof Backrefs;\nexport function buildBackrefs(k: string, v: models.Payload[]): Backrefs {\n  const bucketed: Backrefs = v.reduce(\n    (acc: Backrefs, payload: models.Payload): Backrefs => {\n      const bucket = backrefType(k, payload.topic);\n      const list: models.Payload[] = (acc[bucket] = acc[bucket] || []);\n      list.push(payload);\n      return acc;\n    },\n    {} as Backrefs\n  );\n\n  if (bucketed.notes) {\n    bucketed.notes = bucketed.notes.sort(notesSorter);\n  }\n  if (bucketed.tasks) {\n    bucketed.tasks = orderTaskList(bucketed.tasks);\n  }\n\n  return bucketed;\n}\n\nfunction backrefType(targetId: string, topic: models.Topic): BackrefKey {\n  if (models.hasRef(topic.actionOn, targetId)) {\n    return 'tasks';\n  } else if (topic.title === undefined && !models.isRef(topic.src)) {\n    return 'notes';\n  } else if (models.isRef(topic.src) && topic.src.ref === targetId) {\n    return 'quotes';\n  } else {\n    return 'backrefs';\n  }\n}\n\nfunction appendTaskChain(\n  sorted: models.Payload[],\n  p: models.Payload,\n  tasks: models.Payload[]\n) {\n  sorted.push(p);\n  const nextAction = p.metadata.nextAction;\n  if (nextAction) {\n    const nextPayload = tasks.find(t => t.metadata.id === nextAction.ref);\n    if (!nextPayload) {\n      // TODO add a force option to skip this error\n      return;\n      throw new ComplexError('broken task chain', {\n        currentLink: p,\n        availableTasks: tasks,\n      });\n    }\n    appendTaskChain(sorted, nextPayload, tasks);\n  }\n}\n\nexport function orderTaskList(tasks: models.Payload[]): models.Payload[] {\n  const sorted: models.Payload[] = [];\n  const first = tasks.find(t => t.metadata.firstAction);\n  if (first) appendTaskChain(sorted, first, tasks);\n\n  // This ensures that the editor shows any task items that don't have\n  // ordering information, it just shows them last.\n  tasks.forEach(t => {\n    if (sorted.indexOf(t) === -1) sorted.push(t);\n  });\n\n  return sorted;\n}\n\nexport async function getLastSeq(\n  leveldb: LevelDB\n): Promise<number | string | undefined> {\n  const ret = await leveldb.configs\n    .get('lastSeq')\n    .catch((err: Error) => undefined);\n  debug.storage('lastSeq=%s', ret);\n  return ret;\n}\n\nexport async function updateLevelDB(\n  leveldb: LevelDB,\n  sourceDb: PouchDB.Database,\n  outerLastSeq: string | number\n): Promise<void> {\n  const inner = async (lastSeq: string | number) => {\n    const { last_seq: resultLastSeq, results } = await sourceDb.changes<\n      models.Payload\n    >({\n      include_docs: true,\n      since: lastSeq,\n      limit: 200,\n      batch_size: 200,\n    });\n    debug.network(\n      'pouchdb.changes count=%s seq=%s',\n      results.length,\n      resultLastSeq\n    );\n\n    await eachOfLimit(results, 30, async (change, i) => {\n      if ((i as number) % 100 === 0)\n        debug.storage('topics.putOrDel progress=%s', i);\n      if (change.deleted) {\n        await leveldb.topics.del(lastSlashItem(change.id));\n      } else if (change.doc && change.doc.metadata) {\n        await leveldb.topics.put(lastSlashItem(change.id), change.doc);\n      }\n    });\n\n    await leveldb.configs.put('lastSeq', resultLastSeq);\n    if (results.length > 0)\n      await leveldb.write();\n\n    return { results: results.length, seq: resultLastSeq };\n  };\n\n  const following = async ({\n    results,\n    seq,\n  }: {\n    results: number;\n    seq: string | number;\n  }): Promise<void> => {\n    if (results > 0) {\n      return inner(seq).then(following);\n    }\n  };\n\n  return inner(outerLastSeq).then(following);\n}\n\nexport async function getAllDocs(sourceDb: PouchDB.Database) {\n  debug.network('getAllDocs at=start');\n  const ret = await sourceDb.allDocs<models.Payload>({\n    include_docs: true,\n    update_seq: true,\n    startkey: topicStartKey,\n    endkey: topicEndKey,\n  });\n  debug.network('getAllDocs at=finish count=%s', ret.rows.length);\n  return ret;\n}\n\nexport async function importTopicsToLevelDB(\n  leveldb: LevelDB,\n  sourceDb: PouchDB.Database\n) {\n  const { rows, update_seq: resultSequence } = await getAllDocs(sourceDb);\n\n  await eachOfLimit(rows, 30, async (row, i) => {\n    try {\n      const { doc } = row;\n      if ((i as number) % 100 === 0) debug.storage('topics.put progress=%s', i);\n      if (doc) {\n        debug.trace('topics.Put at=start index=%s id=%s', i, doc.metadata.id);\n        await leveldb.topics.put(doc.metadata.id, doc, {\n          freshIndexes: true,\n        });\n        debug.trace('topics.Put at=finish index=%s id=%s', i, doc.metadata.id);\n      }\n    } catch (e) {\n      reportError(e);\n      throw e;\n    }\n  });\n\n  await leveldb.configs.put('lastSeq', resultSequence);\n  await leveldb.write();\n}\n\nfunction lastSlashItem(docId: string) {\n  return reverseSlashes(docId)[0];\n}\n\nfunction reverseSlashes(v: string) {\n  return v.split('/').reverse();\n}\n","import {\n  AbstractIteratorOptions,\n  AbstractBatch,\n  AbstractOptions,\n  PutBatch,\n  DelBatch,\n} from 'abstract-leveldown';\n\nexport type Indexer<V> = (o: V) => undefined | string | string[];\nexport interface Indexers<V> {\n  [key: string]: Indexer<V>;\n}\nexport type Indexes<V, IDXRS> = { [key in keyof IDXRS]: Index<V> };\n\nexport const ENDstr = '\\xff';\ninterface IndexBase<V> {\n  get(k: string): Promise<V>;\n}\ninterface IndexHolder {\n  forEach(\n    options: AbstractIteratorOptions,\n    fn: (k: string, v: string) => void | Promise<void>\n  ): Promise<void>;\n  batch(\n    array: AbstractBatch<string, string>[],\n    options?: AbstractOptions\n  ): Promise<void>;\n}\nexport class Index<V> {\n  indexer: Indexer<V>;\n  indexDb: IndexHolder;\n  base: IndexBase<V>;\n\n  constructor(base: IndexBase<V>, secondary: IndexHolder, indexer: Indexer<V>) {\n    this.base = base;\n    this.indexDb = secondary;\n    this.indexer = indexer;\n  }\n\n  async get(k: string): Promise<V[]> {\n    return this.getAll({ gte: `${k}!`, lt: `${k}!${ENDstr}` });\n  }\n\n  async getAllKeys(options: AbstractIteratorOptions): Promise<string[]> {\n    const list: string[] = [];\n\n    await this.indexDb.forEach(options, (k, v) => {\n      list.push(k.split('!')[0]);\n    });\n\n    return list;\n  }\n\n  async getAll(options: AbstractIteratorOptions): Promise<V[]> {\n    const list: V[] = [];\n\n    await this.forEach(options, (k, v) => {\n      list.push(v);\n    });\n\n    return list;\n  }\n\n  async forEach(\n    options: AbstractIteratorOptions,\n    fn: (k: string, v: V) => void | Promise<void>\n  ) {\n    await this.indexDb.forEach(options, async (indexedKey, originalKey) => {\n      const value = await this.base.get(originalKey);\n      await fn(originalKey, value);\n    });\n  }\n\n  async updateIndex(\n    batches: AbstractBatch<string, V>[],\n    options: AbstractOptions | undefined,\n    possiblePuts: boolean\n  ) {\n    const indexOps: AbstractBatch<string, string>[] = possiblePuts\n      ? await this.indexDelsBatchList(batches)\n      : this.indexPutsBatchList(batches);\n\n    if (indexOps.length > 0) await this.indexDb.batch(indexOps, options);\n  }\n\n  private async indexDelsBatchList(\n    batches: AbstractBatch<string, V>[]\n  ): Promise<AbstractBatch<string, string>[]> {\n    return (await Promise.all(\n      batches.map(async b =>\n        indexBatch(\n          b,\n          this.indexer,\n          b.type === 'put'\n            ? b.value\n            : await this.base.get(b.key).catch(e => undefined)\n        )\n      )\n    )).flat();\n  }\n\n  private indexPutsBatchList(\n    batches: AbstractBatch<string, V>[]\n  ): AbstractBatch<string, string>[] {\n    return batches\n      .map(b => indexBatch(b, this.indexer, (b as PutBatch).value))\n      .flat();\n  }\n}\n\nfunction indexBatch<V>(\n  b: AbstractBatch<string, V>,\n  indexer: Indexer<V>,\n  value: V | undefined\n): AbstractBatch<string, string>[] {\n  if (value === undefined) {\n    return [];\n  }\n\n  const indexKeys = [indexer(value)].flat().filter(k => k !== undefined);\n  return indexKeys.map(\n    (key: string): AbstractBatch<string, string> => {\n      const indexKey = [key, b.key].join('!');\n      return b.type === 'put'\n        ? ({\n            type: 'put',\n            key: indexKey,\n            value: b.key,\n          } as PutBatch)\n        : ({\n            type: 'del',\n            key: indexKey,\n          } as DelBatch);\n    }\n  );\n}\n","import levelup, { LevelUp } from 'levelup';\nimport {\n  AbstractLevelDOWN,\n  AbstractIterator,\n  AbstractIteratorOptions,\n  AbstractBatch,\n  AbstractOptions,\n  AbstractGetOptions,\n} from 'abstract-leveldown';\nimport { Indexes, Indexers, Index } from './indexing';\nimport sublevel from './sublevel';\nimport { ComplexError, annotateErrors } from '../common/errors';\n\nexport function wrap<V>(db: AbstractLevelDOWN<string, V>) {\n  return new LevelWrapper<V, {}>(db, {});\n}\n\nexport class LevelWrapper<V, IDXRS extends Indexers<V>> {\n  db: LevelUp<AbstractLevelDOWN<string, V>, AbstractIterator<string, V>>;\n  base: LevelUp<AbstractLevelDOWN<string, any>, AbstractIterator<string, any>>;\n  idx: Indexes<V, IDXRS>;\n  private indexed: boolean;\n\n  constructor(db: AbstractLevelDOWN<string, V>, indexers: IDXRS) {\n    this.base = levelup(db);\n    this.db = levelup(sublevel<V, string>(this.base, 'objects'));\n    this.idx = this.buildIndexes(indexers);\n    this.indexed = Object.keys(this.idx).length > 0;\n  }\n\n  private buildIndexes(indexers?: IDXRS): Indexes<V, IDXRS> {\n    if (!indexers) return {} as Indexes<V, IDXRS>;\n\n    const idx = {} as Indexes<V, IDXRS>;\n    for (const k in indexers) {\n      idx[k] = new Index(this, this.sub<string>(`idx-${k}`), indexers[k]);\n    }\n\n    return idx;\n  }\n\n  private async updateIndexes(\n    batches: AbstractBatch<string, V>[],\n    options: AbstractOptions | undefined,\n    delsPossible: boolean = true\n  ) {\n    try {\n      await Promise.all(\n        Object.values(this.idx).map(async indexes =>\n          indexes.updateIndex(batches, options, delsPossible)\n        )\n      );\n    } catch (e) {\n      throw new ComplexError('failed to update indexes for batch', {\n        cause: e,\n        batches,\n      });\n    }\n  }\n\n  async get(key: string, options?: AbstractGetOptions): Promise<V> {\n    return annotateErrors({ key }, () => this.db.get(key, options));\n  }\n\n  async put(key: string, value: V, options?: AbstractOptions) {\n    if (this.indexed && (!options || options.freshIndexes !== true)) {\n      await this.updateIndexes([{ type: 'del', key }], options);\n    }\n\n    await this.db.put(key, value, options);\n    if (this.indexed)\n      await this.updateIndexes([{ type: 'put', key, value }], options, false);\n  }\n\n  async del(key: string, options?: AbstractOptions) {\n    if (this.indexed) await this.updateIndexes([{ type: 'del', key }], options);\n    await this.db.del(key, options);\n  }\n\n  async batch(array: AbstractBatch<string, V>[], options?: AbstractOptions) {\n    await this.db.batch(array, options);\n    if (this.indexed) await this.updateIndexes(array, options);\n  }\n\n  // We need to return a sub function in order to have both a required\n  // type parameter and an inferred type parameter\n  subIndexed<VS>(name: string) {\n    return <SUBIDXRS extends Indexers<VS>>(indexers: SUBIDXRS) =>\n      new LevelWrapper<VS, SUBIDXRS>(\n        sublevel<VS, string>(this.base, name),\n        indexers\n      );\n  }\n\n  sub<VS = V>(name: string) {\n    return new LevelWrapper<VS, {}>(sublevel<VS, string>(this.base, name), {});\n  }\n\n  async getAll(options: AbstractIteratorOptions = {}): Promise<V[]> {\n    const list: V[] = [];\n\n    await this.forEach(options, (k, v) => {\n      list.push(v);\n    });\n\n    return list;\n  }\n\n  async forEach(\n    options: AbstractIteratorOptions,\n    fn: (k: string, v: V) => void | Promise<void>\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const iter = this.db.iterator(options);\n\n      function next() {\n        iter.next((err, key, value) => {\n          if (err) {\n            iter.end(err2 => {\n              reject(new ComplexError(err));\n            });\n          } else {\n            if (key && value) {\n              Promise.resolve()\n                .then(async () => fn(key, value))\n                .then(next, reject);\n            } else {\n              iter.end(err2 => {\n                if (err2) {\n                  reject(new ComplexError(err2));\n                } else {\n                  resolve();\n                }\n              });\n            }\n          }\n        });\n      }\n\n      next();\n    });\n  }\n}\n","import encoding from 'encoding-down';\nimport levelup from 'levelup';\nimport { AbstractLevelDOWN } from 'abstract-leveldown';\nimport { WordTokenizer } from 'natural/lib/natural/tokenizers/regexp_tokenizer';\nimport { wrap, LevelWrapper } from '../leveldown';\nimport { Indexer } from '../leveldown/indexing';\nimport batching from '../leveldown/batch';\nimport * as models from './models';\nimport debug from './debug';\n\nexport const codeStorageVersion = 12;\n\nconst tokenizer = new WordTokenizer();\n\nexport interface LevelDB {\n  write: () => Promise<void>;\n  topics: LevelWrapper<\n    models.Payload,\n    {\n      backrefs: Indexer<models.Payload>;\n      terms: Indexer<models.Payload>;\n    }\n  >;\n  configs: LevelWrapper<any, {}>;\n  uploads: LevelWrapper<models.Create, {}>;\n}\nexport function buildLevelDB(\n  leveljsStore: AbstractLevelDOWN<any, any>\n): LevelDB {\n  const batched = batching<any, string>(\n    levelup(encoding<string, any>(leveljsStore, { valueEncoding: 'json' }))\n  );\n  const base = wrap(batched.db);\n\n  const write = async () => {\n    debug.storage('batched.write at=start');\n    await batched.write();\n    debug.storage('batched.write at=finish');\n  };\n\n  const topics = base.subIndexed<models.Payload>('topics')({\n    backrefs: p => {\n      const refs = models.getAllRefs(p.topic).map(r => r.ref);\n      return refs;\n    },\n    terms: ({ topic: p }) => {\n      return [p.text || [], p.title || []]\n        .flat()\n        .flatMap(s => tokenizer.tokenize(s.toLowerCase()))\n        .filter(s => s.length > 2 && s.match(/^[a-z]+$/));\n    },\n  });\n\n  const uploads = base.sub<models.Create>('uploads');\n  const configs = base.sub<any>('configs');\n\n  return {\n    write,\n    topics,\n    configs,\n    uploads,\n  };\n}\n\nexport function isTestEnv(): boolean {\n  return process.env.NODE_ENV === 'test';\n}\n","import PouchDB from 'pouchdb';\nimport cuid from 'cuid';\nimport debug from '../../common/debug';\n\nimport {\n  catchError,\n  reportError,\n  ComplexError,\n  annotateErrors,\n} from '../../common/errors';\nimport * as models from '../../common/models';\nimport { wrapProfiling } from '../../common/performance';\nimport { Rendezvous } from '../../common/typed_event';\nimport {\n  getLastSeq,\n  updateLevelDB,\n  importTopicsToLevelDB,\n} from '../../common/content';\nimport leveljs from 'level-js';\nimport memdown from 'memdown';\nimport {\n  buildLevelDB,\n  isTestEnv,\n  codeStorageVersion,\n} from '../../common/leveldb';\n\nexport const loading = new Rendezvous<boolean>('dataLoading');\n\nconst leveljsStore = isTestEnv() ? memdown() : leveljs('wiki');\nexport const leveldb = buildLevelDB(leveljsStore);\n\nexport async function getReverseMappings({\n  topic,\n  metadata,\n}: models.Payload): Promise<models.Payload[]> {\n  const outbound = models.getAllRefs(topic, true).map(r => r.ref);\n  const backrefs = await leveldb.topics.idx.backrefs.get(metadata.id);\n\n  return backrefs\n    .filter(d => d.metadata.stale_at === undefined)\n    .filter(d => outbound.indexOf(d.metadata.id) === -1);\n}\n\nexport async function getTopic(\n  topicKey: string\n): Promise<models.Payload | undefined> {\n  return annotateErrors({ topicKey }, async () =>\n    leveldb.topics.get(topicKey)\n  ).catch(err => {\n    if (err.name === 'NotFoundError' && err.details) {\n      if (loading.isPending()) {\n        return loading.then(() => getTopic(topicKey));\n      } else {\n        console.log({ error: err.message, ...err.details });\n      }\n    } else {\n      reportError(err);\n    }\n  });\n}\n\nexport async function addNote(topicId: string, text: string) {\n  if (topicId === 'index') {\n    topicId = 'inbox';\n  }\n  text = text.trim();\n  const id = cuid();\n  const payload: models.Update = {\n    _id: topicToDocID(id),\n    metadata: { id, created_at: Date.now() },\n    topic: {\n      broader: [{ ref: topicId }],\n    },\n  };\n  if (text.startsWith('http')) {\n    payload.topic.link = text;\n  } else {\n    payload.topic.text = text;\n  }\n\n  await leveldb.uploads.put(id, payload);\n  await leveldb.topics.put(id, payload);\n  await leveldb.write();\n\n  if (navigator.onLine) {\n    const remoteDb = getRemoteDb();\n    catchError(async () => attemptNoteUpload(payload, remoteDb), {\n      at: 'data.addNote',\n    });\n  }\n}\nexport function configure(value: string) {\n  JSON.parse(value);\n  localStorage.couchdb_target = value;\n\n  backgroundSync();\n}\n\nasync function isConfigured(): Promise<boolean> {\n  if (!navigator.onLine) {\n    return true;\n  }\n\n  const config = getDbTarget();\n  if (!config) {\n    return false;\n  }\n\n  const remoteDb = getRemoteDb();\n\n  // TODO once I have a better idea of what errors from\n  // this can look like I'll delete the config and return\n  // false sometimes\n  catchError(async () => remoteDb.info(), {\n    at: 'data.isConfigured',\n  });\n\n  return true;\n}\n\nexport async function uploadNotes(sourceDb: PouchDB.Database) {\n  await leveldb.uploads.forEach({}, async (k, doc) => {\n    await attemptNoteUpload(doc, sourceDb);\n  });\n}\n\nexport async function initialize(): Promise<boolean> {\n  const ready = await isConfigured();\n  if (!ready) {\n    return false;\n  }\n\n  backgroundSync();\n\n  return true;\n}\n\nfunction backgroundSync() {\n  if (loading.hasFired()) return;\n\n  if (!navigator.onLine) {\n    loading.done(true);\n    return;\n  }\n\n  catchError(\n    async () => {\n      try {\n        const remoteDb = getRemoteDb();\n        await syncToLevelDB(remoteDb);\n        await uploadNotes(remoteDb);\n      } finally {\n        loading.done(true);\n      }\n    },\n    { at: 'data.backgroundSync' }\n  );\n}\n\nasync function syncToLevelDB(sourceDb: PouchDB.Database) {\n  await wrapProfiling('syncToLevelDB', async () => {\n    const lastSeq = await getLastSeq(leveldb);\n    const schemaCurrent = await isStorageSchemaCurrent();\n\n    if (!lastSeq || !schemaCurrent) {\n      await resetStorageSchema();\n      await importTopicsToLevelDB(leveldb, sourceDb);\n    } else {\n      await updateLevelDB(leveldb, sourceDb, lastSeq);\n    }\n  });\n}\n\nasync function isStorageSchemaCurrent(): Promise<boolean> {\n  const value = await leveldb.configs\n    .get('storageVersion')\n    .catch((err: Error) => undefined);\n  debug.storage(\n    'storageVersion=%s codeStorageVersion=%s',\n    value,\n    codeStorageVersion\n  );\n\n  return value && value >= codeStorageVersion;\n}\n\nasync function resetStorageSchema() {\n  debug.storage('Resetting storage schema');\n  await leveljsStore.store('readwrite').clear();\n  await leveldb.configs.put('storageVersion', codeStorageVersion);\n  await leveldb.write();\n}\n\nlet remoteDbMemoized: PouchDB.Database;\nfunction getRemoteDb() {\n  if (!remoteDbMemoized) {\n    const config = getDbTarget();\n\n    if (!config) {\n      throw new Error('database configuration unavailable');\n    }\n\n    remoteDbMemoized = new PouchDB(config.url, config);\n  }\n\n  return remoteDbMemoized;\n}\n\ntype DbConfigObject = {\n  url: string;\n} & PouchDB.Configuration.RemoteDatabaseConfiguration;\nfunction getDbTarget(): DbConfigObject | undefined {\n  if (!localStorage.couchdb_target) {\n    return;\n  }\n\n  try {\n    const config = JSON.parse(localStorage.couchdb_target);\n    if (!config.url || !config.auth) {\n      throw new Error('Invalid db target config');\n    }\n\n    return config;\n  } catch (e) {\n    reportError(e);\n    delete localStorage.couchdb_target;\n  }\n}\n\nasync function attemptNoteUpload(\n  payload: models.Create<models.Payload>,\n  sourceDb: PouchDB.Database\n) {\n  try {\n    await sourceDb.put(payload);\n  } catch (e) {\n    if (e.status !== 409) {\n      reportError(e);\n      return;\n    }\n  }\n\n  await leveldb.uploads.del(payload.metadata.id, { writeBatch: true });\n}\n\nfunction topicToDocID(topicID: string): string {\n  if (topicID.startsWith('/')) {\n    throw new ComplexError('invalid topicID', {\n      topicID,\n    });\n  }\n\n  return `$/topics/${topicID}`;\n}\n","import { getTopic, getReverseMappings, loading as dataLoading } from './data';\nimport * as models from '../../common/models';\nimport {\n  deriveTitle,\n  buildBackrefs,\n  Backrefs,\n  refSorter,\n} from '../../common/content';\nimport { annotateErrors } from '../../common/errors';\n\ntype FieldsAndHeadings = [models.TopicKeys, string][];\nconst NestedSectionListFieldNames: FieldsAndHeadings = [\n  ['broader', 'Broader'],\n  ['related', 'Related'],\n  ['links', 'Links'],\n];\n\nexport interface AbstractPage {\n  title: string;\n  sections: Section[];\n}\n\nexport interface Section {\n  title?: string;\n  text?: string;\n  src?: any;\n  divs?: Div[];\n}\n\nexport interface Div {\n  heading?: string;\n  list: TextObject[];\n}\n\nconst sectionFunctions: ((\n  d: models.Payload,\n  b: Backrefs\n) => Promise<Section | Section[]>)[] = [\n  frontSection,\n  listSections,\n  otherFieldsSection,\n];\nexport async function buildAbstractPage(\n  topicId: string,\n  cb: (p: AbstractPage) => void,\n  progressiveRender: boolean = true\n): Promise<void> {\n  const doc = await getTopic(topicId);\n  if (!doc) {\n    return cb({\n      title: topicId,\n      sections: [\n        {\n          text: 'No such topic',\n        },\n      ],\n    });\n  }\n\n  const reloadWhenDone = dataLoading.isPending();\n\n  await annotateErrors({ doc }, async () => {\n    const page: AbstractPage = {\n      title: deriveTitle(doc.topic),\n      sections: [] as Section[],\n    };\n    if (progressiveRender) cb(page);\n\n    const list = await getReverseMappings(doc);\n    const bucketed = buildBackrefs(doc.metadata.id, list);\n\n    await sectionFunctions.reduce(async (acc, fn) => {\n      await acc;\n      const sections = [await fn(doc, bucketed)].flat();\n      sections.forEach(s => page.sections.push(s));\n\n      if (progressiveRender) cb(page);\n    }, Promise.resolve());\n\n    if (!progressiveRender) cb(page);\n  });\n\n  if (reloadWhenDone)\n    await dataLoading.then(() => buildAbstractPage(topicId, cb, false));\n}\n\nasync function buildTasksDiv(bucketed: Backrefs): Promise<Div[]> {\n  const list = await maybePayloadsToTextObjects(bucketed.tasks);\n  if (list.length === 0) return [];\n  return [{ heading: 'Tasks', list }];\n}\n\nasync function frontSection(\n  { topic }: models.Payload,\n  backrefs: Backrefs\n): Promise<Section | never[]> {\n  const divs = [\n    await maybeListDiv(topic.collection),\n    await buildTasksDiv(backrefs),\n  ].flat();\n\n  if (!topic.text && divs.length === 0) return [];\n\n  return {\n    text: topic.text,\n    src: topic.src,\n    divs,\n  };\n}\n\nasync function listSections({\n  topic,\n  metadata,\n}: models.Payload): Promise<Section[]> {\n  if (topic.narrower) {\n    return Promise.all(\n      topic.narrower.map(async s => {\n        const sectionDoc = await getTopic(s.ref);\n        if (!sectionDoc) {\n          return { text: `Missing ${s.ref}` };\n        }\n        return topicSection(sectionDoc.topic, id => id === metadata.id);\n      })\n    );\n  } else {\n    return [];\n  }\n}\n\nasync function topicSection(doc: models.Topic, context: LinkSilencer) {\n  return annotateErrors(\n    { doc },\n    async (): Promise<Section> => {\n      return {\n        title: deriveTitle(doc),\n        text: doc.text,\n        divs: [\n          await maybeListDiv(doc.narrower || doc.collection),\n          await listFieldNameDivs(NestedSectionListFieldNames, doc, context),\n        ].flat(),\n      };\n    }\n  );\n}\n\nasync function maybeListDiv(input: undefined | any[]): Promise<Div | never[]> {\n  const list = await maybeLabelRefs(input);\n  return list ? { list } : [];\n}\n\nasync function listFieldNameDivs(\n  names: FieldsAndHeadings,\n  doc: models.Topic,\n  context?: LinkSilencer\n): Promise<Div[]> {\n  return (await Promise.all(\n    names.map(\n      async ([field, heading]): Promise<Div | never[]> => {\n        const list = await maybeLabelRefs(doc[field] as any[], context);\n        return list ? { heading, list } : [];\n      }\n    )\n  )).flat();\n}\n\nexport async function maybePayloadsToTextObjects(\n  ...list: (models.Payload[] | undefined)[]\n): Promise<TextObject[]> {\n  return Promise.all(\n    list\n      .filter(l => Array.isArray(l))\n      .flat()\n      .map(topicToTextObject)\n  );\n}\n\nasync function maybeAddRefTextObjects(\n  list: models.Ref[] | undefined,\n  tos: TextObject[]\n) {\n  if (!list) return;\n  (await Promise.all(list.map(refToTextObject))).flat().forEach(to => {\n    if (!tos.some(rto => rto.ref === to.ref)) {\n      tos.unshift(to);\n    }\n  });\n}\n\nasync function buildRelatedDivList(\n  doc: models.Payload,\n  bucketed: Backrefs\n): Promise<{ related: TextObject[]; notes: TextObject[] }> {\n  const notes = await maybePayloadsToTextObjects(\n    bucketed.notes,\n    bucketed.quotes\n  );\n  let related = await maybePayloadsToTextObjects(bucketed.backrefs);\n\n  await maybeAddRefTextObjects(doc.topic.actionOn, related);\n  await maybeAddRefTextObjects(doc.topic.related, related);\n  await maybeAddRefTextObjects(doc.topic.broader, related);\n\n  related = related.sort(refSorter);\n\n  return { related, notes };\n}\n\nasync function otherFieldsSection(\n  doc: models.Payload,\n  backrefs: Backrefs\n): Promise<Section | Section[]> {\n  const { related, notes } = await buildRelatedDivList(doc, backrefs);\n  const divs = [\n    { heading: 'Related', list: related },\n    { heading: 'Links', list: (await maybeLabelRefs(doc.topic.links)) || [] },\n    { heading: 'Notes', list: notes },\n  ].filter(d => d.list && d.list.length > 0);\n\n  if (divs.length === 0) return [];\n\n  return { divs };\n}\n\ntype LinkSilencer = (s: string) => boolean;\nasync function maybeLabelRefs(\n  list: undefined | any[],\n  silencer?: LinkSilencer\n): Promise<undefined | TextObject[]> {\n  if (!list || list.length === 0) return;\n\n  const ret = (await Promise.all(\n    list.map(async v => {\n      if (!models.isRef(v)) return v;\n      if (silencer && silencer(v.ref)) return [];\n      return refToTextObject(v);\n    })\n  )).flat();\n\n  if (ret.length > 0) return ret;\n}\n\nasync function refToTextObject(ref: models.Ref): Promise<TextObject | never[]> {\n  const doc = await getTopic(ref.ref);\n  if (!doc) {\n    return { text: `Missing ${ref.ref}` };\n  } else if (doc.metadata.stale_at) {\n    return [];\n  } else {\n    return topicToTextObject(doc);\n  }\n}\n\nexport interface TextObject {\n  ref?: string;\n  label?: string;\n  text?: string;\n  src?: any;\n}\nasync function topicToTextObject({\n  topic,\n  metadata,\n}: models.Payload): Promise<TextObject> {\n  if (topic.title) {\n    return {\n      ref: metadata.id,\n      label: deriveTitle(topic),\n    };\n  } else if (!topic.text) {\n    return {\n      ref: metadata.id,\n      label: deriveTitle(topic),\n    };\n  } else {\n    return {\n      ref: metadata.id,\n      text: topic.text,\n      src: await maybeResolveSrc(topic.src),\n    };\n  }\n}\n\n// could be lots of things\nasync function maybeResolveSrc(src: undefined | models.Link) {\n  if (!src) return;\n  if (models.isRef(src)) {\n    const srcNode = await getTopic(src.ref);\n    if (!srcNode) {\n      return `Missing ${src.ref}`;\n    }\n    return {\n      ref: src.ref,\n      label: deriveTitle(srcNode.topic),\n    };\n  } else {\n    return src;\n  }\n}\n","import React from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { Link } from 'react-router-dom';\nimport { Menu } from './menu';\nimport { PageHeader } from './elements';\nimport { useAsync } from './use_async';\nimport { buildAbstractPage, Section, Div } from '../utils/abstract_page';\n\nexport function TopicPage(props: RouteComponentProps<{ topicId: string }>) {\n  const { topicId } = props.match.params;\n  const page = useAsync(topicId, buildAbstractPage);\n\n  return (\n    <div className=\"topicPage\">\n      <Menu>\n        <li>\n          <Link to=\"/index\">index</Link>\n        </li>\n        <li>\n          <Link to={`/add_note/${topicId}`}>add note</Link>\n        </li>\n      </Menu>\n\n      {page && <PageHeader title={page.title} />}\n      {page && renderSections(page.sections)}\n    </div>\n  );\n}\n\nfunction renderSections(sections: Section[]) {\n  return sections.map((s, i) => {\n    return (\n      <section key={i}>\n        {s.title && <h2 className=\"title\">{s.title}</h2>}\n        {s.text && textItem(s, false)}\n        {s.divs && sectionDivs(s.divs)}\n      </section>\n    );\n  });\n}\n\nfunction sectionDivs(divs: Div[]) {\n  return divs.map((d, i) => {\n    return (\n      <div key={i}>\n        {d.heading && <h3 className=\"title\">{d.heading}</h3>}\n        {simpleList(d.list)}\n      </div>\n    );\n  });\n}\n\nexport function simpleList(list: any[]) {\n  return (\n    <ul>\n      {list.map((s, i) => (\n        <li key={i}>{textItem(s)}</li>\n      ))}\n    </ul>\n  );\n}\n\nexport function textItem(item: any, showMore: boolean = true) {\n  if (!item) {\n    throw new Error('item parameter is missing');\n  } else if (typeof item === 'string') {\n    if (item.startsWith('http')) {\n      return buildAnchorElement(item);\n    }\n    return <p>{item}</p>;\n  } else if (!item.text && (item.link || item.search)) {\n    return buildAnchorElement(item);\n  } else if (item.label) {\n    return refLink(item.ref, item.label);\n  } else {\n    return (\n      <p>\n        {item.text}\n        {item.src && <span> - {renderSrc(item.src)} </span>}\n        {showMore && <span> ({refLink(item.ref, 'more', 'moreLink')})</span>}\n      </p>\n    );\n  }\n}\n\nfunction renderSrc(src: any) {\n  if (!src) {\n    return undefined;\n  } else if (typeof src === 'string') {\n    return buildAnchorElement({ link: src, title: 'src' });\n  } else if (src.ref) {\n    return refLink(src.ref, src.label);\n  } else {\n    // TODO replace this, it could be a labeled link\n    return <pre>{JSON.stringify(src)}</pre>;\n  }\n}\n\nfunction buildAnchorElement(obj: any) {\n  const mobile = document.documentElement.clientWidth < 800;\n\n  if (typeof obj === 'string' || obj.link) {\n    let target = obj;\n    let text = obj;\n\n    if (typeof obj !== 'string') {\n      target = obj.link;\n      text = obj.title || obj.link;\n    }\n\n    if (text.startsWith('https://en.wikipedia.org/wiki')) {\n      text = `Wikipedia: ${text\n        .replace('https://en.wikipedia.org/wiki/', '')\n        .replace(/_/g, ' ')}`;\n    } else if (text.indexOf('pinboard.in/u:curzonj/') !== -1) {\n      text = `Pinboard: ${text\n        .replace(/https?:\\/\\/pinboard.in\\/u:curzonj\\//, '')\n        .split('/')\n        .filter((l: string) => l !== '')\n        .flatMap((l: string) => l.replace(/^t:/, ''))\n        .join(', ')}`;\n      target = target.replace(/^http:\\/\\//, 'https://');\n      if (mobile) {\n        target = target.replace('pinboard.in', 'm.pinboard.in');\n      }\n    }\n\n    return (\n      <a target=\"_blank\" rel=\"noopener noreferrer\" href={target}>\n        {text}\n      </a>\n    );\n  }\n  if (obj.search) {\n    return (\n      <a\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        href={'https://google.com/search?q=' + encodeURIComponent(obj.search)}\n      >\n        Google: {obj.search}\n      </a>\n    );\n  }\n\n  return undefined;\n}\n\nfunction refLink(link: string, text: string, cssClass: string = 'refLink') {\n  return (\n    <Link className={cssClass} to={encodeURI(link)}>\n      {text || link}\n    </Link>\n  );\n}\n","import React, { useState } from 'react';\nimport { catchError } from '../../common/errors';\nimport { Menu } from './menu';\n\ntype Props = {\n  handler: (s: string) => void;\n} & React.HTMLAttributes<HTMLDivElement>;\n\nexport const BigTextAreaPage: React.FC<Props> = ({\n  handler,\n  children,\n  ...restProps\n}) => {\n  const [textValue, setTextValue] = useState('');\n\n  function onKeyDown(e: React.KeyboardEvent<HTMLTextAreaElement>) {\n    if (e.which === 13 && (e.metaKey || e.shiftKey)) onSubmitHandler(e);\n  }\n\n  function onSubmitHandler(e: React.SyntheticEvent) {\n    e.preventDefault();\n    catchError(() => handler(textValue));\n  }\n\n  function onChange(e: React.ChangeEvent<HTMLTextAreaElement>) {\n    if (e && e.target) {\n      setTextValue(e.target.value);\n    }\n  }\n\n  return (\n    <div {...restProps}>\n      <Menu>\n        <li>\n          <button\n            type=\"button\"\n            className=\"link-button\"\n            onClick={onSubmitHandler}\n          >\n            done\n          </button>\n        </li>\n      </Menu>\n\n      {children}\n\n      <form>\n        <textarea\n          onKeyDown={onKeyDown}\n          autoComplete=\"on\"\n          autoCapitalize=\"sentences\"\n          required\n          onChange={onChange}\n          value={textValue}\n        ></textarea>\n      </form>\n    </div>\n  );\n};\n","import React from 'react';\nimport { RouteComponentProps } from 'react-router';\nimport { addNote } from '../utils/data';\nimport { PageHeader } from './elements';\nimport { BigTextAreaPage } from './big_textarea';\nimport { useAsync } from './use_async';\nimport { getTopic } from '../utils/data';\nimport { deriveTitle } from '../../common/content';\n\nexport const NotePage: React.FC<\n  RouteComponentProps<{ topicId: string }>\n> = props => {\n  const { topicId } = props.match.params;\n  const payload = useAsync(topicId, getTopic);\n\n  async function onSubmit(text: string) {\n    if (text.trim() !== '') {\n      await addNote(topicId, text);\n    }\n\n    props.history.push(`/${topicId}`);\n  }\n\n  return (\n    <BigTextAreaPage className=\"topicPage\" handler={onSubmit}>\n      {payload && <PageHeader title={deriveTitle(payload.topic)} />}\n    </BigTextAreaPage>\n  );\n};\n","import React, { useState } from 'react';\nimport { withRouter, RouteComponentProps } from 'react-router';\nimport BarLoader from 'react-spinners/BarLoader';\nimport { catchError } from '../../common/errors';\nimport { configure, initialize, loading } from '../utils/data';\nimport { BigTextAreaPage } from './big_textarea';\nimport { css } from '@emotion/core';\n\nexport const LoginPage: React.FC<RouteComponentProps> = props => {\n  async function onSubmit(text: string) {\n    configure(text);\n\n    // The topics page will wait for the data to finish\n    // loading. We go to that page now so the user has some\n    // feedback when the submit the configuration\n    props.history.push('/index');\n  }\n\n  return (\n    <BigTextAreaPage handler={onSubmit}>\n      <div className=\"header\">\n        <h1 className=\"title\">Enter the configuration</h1>\n      </div>\n    </BigTextAreaPage>\n  );\n};\n\nconst loadingBarCss = css`\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  z-index: -1;\n`;\n\nexport const LoginRedirector = withRouter((props: RouteComponentProps) => {\n  const [dbInitialized, setInitialized] = useState(false);\n  const [dataLoaded, setDataLoaded] = useState(loading.hasFired());\n\n  if (!dataLoaded) loading.once((err, done) => setDataLoaded(true));\n\n  if (!dbInitialized && props.location.pathname !== '/login') {\n    catchError(async () => {\n      const ok = await initialize();\n      if (ok) {\n        setInitialized(true);\n      } else {\n        props.history.push('/login');\n      }\n    });\n  }\n\n  return (\n    <BarLoader\n      css={loadingBarCss}\n      widthUnit={'%'}\n      width={100}\n      color={'rgb(54, 215, 183)'}\n      loading={!dataLoaded}\n    />\n  );\n});\n","import React from 'react';\nimport { Menu } from './menu';\nimport { Link } from 'react-router-dom';\nimport './menu_page.css';\n\nexport function MenuPage(props: {}) {\n  return (\n    <div className=\"menuPage\">\n      <Menu>\n        <li>\n          <Link to=\"/index\">index</Link>\n        </li>\n      </Menu>\n\n      <ul>\n        <li>\n          <Link to=\"/search\">search</Link>\n        </li>\n        <li>\n          <Link to=\"/recent\">recent</Link>\n        </li>\n      </ul>\n    </div>\n  );\n}\n","import React, { useState } from 'react';\nimport { Link, useLocation, useHistory } from 'react-router-dom';\nimport { leveldb } from '../utils/data';\nimport { ENDstr } from '../../leveldown/indexing';\nimport debug from '../../common/debug';\nimport { useAsync } from './use_async';\nimport { Menu } from './menu';\nimport { maybePayloadsToTextObjects, TextObject } from '../utils/abstract_page';\nimport { notesSorter } from '../../common/content';\nimport { simpleList } from './topic_page';\nimport './search_page.css';\n\nexport type MaybeString = string | undefined | null;\nexport function SearchPage(props: {}) {\n  const history = useHistory();\n  const location = useLocation();\n  const query = new URLSearchParams(location.search);\n  const searchTerm = query.get('search');\n  const [textValue, setTextValue] = useState<string>();\n  debug.trace({ textValue, searchTerm });\n  const results = useAsync<TextObject[], MaybeString>(\n    searchTerm,\n    async (term: MaybeString): Promise<TextObject[]> => {\n      if (!term) return [];\n      const terms = await leveldb.topics.idx.terms.getAll({\n        gte: term,\n        lt: [term, ENDstr].join(''),\n      });\n      return maybePayloadsToTextObjects(terms.sort(notesSorter));\n    },\n    { wait: 200, leading: true, fuzzy: true }\n  );\n\n  function onChange(e: React.ChangeEvent<HTMLInputElement>) {\n    if (e && e.target) {\n      let value = e.target.value.toLowerCase().trim();\n      debug.uiEvents('onChange value=%s', value);\n      if (value.length > 2) {\n        history.replace({ ...location, search: `?search=${value}` });\n        setTextValue(value);\n      } else {\n        history.replace({ ...location, search: '' });\n        setTextValue(undefined);\n      }\n    }\n  }\n\n  function onSubmit(e: React.FormEvent) {\n    debug.uiEvents('onSubmit');\n    e.preventDefault();\n  }\n\n  return (\n    <div className=\"searchPage\">\n      <Menu>\n        <li>\n          <Link to=\"/index\">index</Link>\n        </li>\n      </Menu>\n\n      <form onSubmit={onSubmit}>\n        <input placeholder=\"Search for...\" onChange={onChange} />\n      </form>\n      {searchTerm && results && simpleList(results)}\n    </div>\n  );\n}\n","import React, { useState, useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport { leveldb } from '../utils/data';\nimport debug from '../../common/debug';\nimport { catchError } from '../../common/errors';\nimport { Menu } from './menu';\nimport { PageHeader } from './elements';\nimport { maybePayloadsToTextObjects, TextObject } from '../utils/abstract_page';\nimport { notesSorter } from '../../common/content';\nimport { simpleList } from './topic_page';\nimport * as models from '../../common/models';\n\nexport function RecentPage(props: {}) {\n  const [results, setResults] = useState<TextObject[]>();\n\n  useEffect(() => catchError(async () => {\n    const topics: models.Payload[] = await leveldb.topics.getAll();\n    const text = await maybePayloadsToTextObjects(topics.sort(notesSorter).slice(0,200));\n\n    setResults(text);\n  }));\n\n  return (\n    <div className=\"recentPage\">\n      <Menu>\n        <li>\n          <Link to=\"/index\">index</Link>\n        </li>\n      </Menu>\n\n      <PageHeader title=\"Recent Entries\" />\n      {results && simpleList(results)}\n    </div>\n  );\n}\n","import React from 'react';\nimport { withRouter, RouteComponentProps } from 'react-router';\n\nclass ScrollToTopInner extends React.Component<RouteComponentProps> {\n  componentDidUpdate(prevProps: RouteComponentProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      if (window.name !== 'nodejs') window.scrollTo(0, 0);\n    }\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\nexport const ScrollToTop = withRouter(ScrollToTopInner);\n","import React, { useState } from 'react';\n\nexport function LoadingStats(props: { duration?: number }) {\n  const [pastTime, setState] = useState(false);\n\n  if (pastTime) return <></>;\n\n  setTimeout(() => setState(true), props.duration || 2000);\n  return (\n    <span className=\"codeversion\">\n      {process.env.REACT_APP_GIT_SHA || 'gitsha'}\n    </span>\n  );\n}\n","import React from 'react';\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from 'react-router-dom';\nimport './app.css';\nimport { TopicPage } from './topic_page';\nimport { NotePage } from './note_page';\nimport { LoginPage, LoginRedirector } from './login_page';\nimport { MenuPage } from './menu_page';\nimport { SearchPage } from './search_page';\nimport { RecentPage } from './recent_page';\nimport { ScrollToTop } from './scroll';\nimport { LoadingStats } from './loading_stats';\n\nexport const App: React.FC = () => {\n  return (\n    <Router basename={process.env.PUBLIC_URL}>\n      <LoginRedirector />\n      <LoadingStats />\n\n      <ScrollToTop>\n        <Switch>\n          <Redirect from=\"/\" to=\"/index\" exact />\n          <Route path=\"/login\" component={LoginPage} />\n          <Route path=\"/menu\" component={MenuPage} />\n          <Route path=\"/search\" component={SearchPage} />\n          <Route path=\"/recent\" component={RecentPage} />\n          <Route path=\"/add_note/:topicId+\" component={NotePage} />\n          <Route path=\"/:topicId+\" component={TopicPage} />\n        </Switch>\n      </ScrollToTop>\n    </Router>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './web/index.css';\nimport { App } from './web/comps/app';\nimport * as serviceWorker from './web/serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n","import { LevelUp } from 'levelup';\nimport { Bytes } from 'leveldown';\nimport {\n  AbstractLevelDOWN,\n  AbstractOpenOptions,\n  ErrorCallback,\n  AbstractIterator,\n  AbstractIteratorOptions,\n  AbstractGetOptions,\n  ErrorValueCallback,\n  AbstractOptions,\n  AbstractBatch,\n} from 'abstract-leveldown';\n\ninterface ImplementsAbstractLevelDOWN<K extends Bytes, V> {\n  _open?(options: AbstractOpenOptions, cb: ErrorCallback): void;\n  _close?(cb: ErrorCallback): void;\n  _get?(key: K, options: AbstractGetOptions, cb: ErrorValueCallback<V>): void;\n  _put?(key: K, value: V, options: AbstractOptions, cb: ErrorCallback): void;\n  _del?(key: K, options: AbstractOptions, cb: ErrorCallback): void;\n  _batch?(\n    array: AbstractBatch<K, V>[],\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ): void;\n  _iterator?(options: AbstractIteratorOptions<K>): AbstractIterator<K, V>;\n}\n\nexport type ALD<K> = AbstractLevelDOWN<K, any>;\nexport type LUP<K> = LevelUp<ALD<K>, AbstractIterator<K, any>>;\n\nexport interface WrappingHandler<V, K extends Bytes> {\n  type: string;\n\n  down?(db: ALD<K>): ALD<K> | undefined;\n  get?(\n    db: ALD<K>,\n    key: K,\n    options: AbstractGetOptions,\n    cb: ErrorValueCallback<V>\n  ): void;\n  put(\n    db: ALD<K>,\n    key: K,\n    value: V,\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ): void;\n  del(db: ALD<K>, key: K, options: AbstractOptions, cb: ErrorCallback): void;\n  batch(\n    db: ALD<K>,\n    array: AbstractBatch<K, V>[],\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ): void;\n  iterator?(\n    src: ALD<K>,\n    nested: ALD<K>,\n    options: AbstractIteratorOptions<K>\n  ): AbstractIterator<K, V>;\n}\n\nexport class WrappedAbstract<V, K extends Bytes> extends AbstractLevelDOWN<K, V>\n  implements ImplementsAbstractLevelDOWN<K, V> {\n  readonly type: string;\n  db: LUP<K>;\n  leveldown?: ALD<K>;\n  handlers: WrappingHandler<V, K>;\n\n  constructor(db: LUP<K>, handlers: WrappingHandler<V, K>) {\n    super('');\n\n    this.handlers = handlers;\n    this.type = handlers.type;\n    this.db = db;\n  }\n\n  _open(options: AbstractOpenOptions, cb: ErrorCallback) {\n    this.db.open(err => {\n      if (err) return cb(err);\n\n      this.leveldown = this.handlers.down\n        ? this.handlers.down(this.db)\n        : ((this.db as any).db as ALD<K>);\n\n      cb(undefined);\n    });\n  }\n\n  _close(cb: ErrorCallback) {\n    this.ifOpen(cb, db => db.close(cb));\n  }\n\n  _get(key: K, options: AbstractGetOptions, cb: ErrorValueCallback<V>) {\n    this.ifOpen(cb, db =>\n      this.handlers.get\n        ? this.handlers.get(db, key, options, cb)\n        : db.get(key, options, cb)\n    );\n  }\n\n  _put(key: K, value: V, options: AbstractOptions, cb: ErrorCallback) {\n    this.ifOpen(cb, db => this.handlers.put(db, key, value, options, cb));\n  }\n\n  _del(key: K, options: AbstractOptions, cb: ErrorCallback) {\n    this.ifOpen(cb, db => this.handlers.del(db, key, options, cb));\n  }\n\n  _batch(\n    operations: AbstractBatch<K, V>[],\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ) {\n    this.ifOpen(cb, db => this.handlers.batch(db, operations, options, cb));\n  }\n\n  _iterator(options: AbstractIteratorOptions<K>): AbstractIterator<K, V> {\n    if (this.leveldown === undefined) {\n      throw new Error('not open yet');\n    }\n\n    return this.handlers.iterator\n      ? this.handlers.iterator(this, this.leveldown, options)\n      : this.leveldown.iterator(options);\n  }\n\n  private ifOpen(\n    cb: ErrorCallback | ErrorValueCallback<V>,\n    fn: (db: ALD<K>) => void\n  ) {\n    if (this.leveldown) {\n      fn(this.leveldown);\n    } else {\n      (cb as ErrorCallback)(new Error('not open yet'));\n    }\n  }\n}\n","import { Bytes } from 'leveldown';\nimport wrap from 'level-option-wrap';\nimport {\n  AbstractLevelDOWN,\n  ErrorCallback,\n  AbstractIterator,\n  AbstractIteratorOptions,\n  AbstractGetOptions,\n  ErrorValueCallback,\n  ErrorKeyValueCallback,\n  AbstractOptions,\n} from 'abstract-leveldown';\nimport { WrappedAbstract, WrappingHandler, LUP } from './wrap_abstract';\n\nexport type WritableBatch<K = any, V = any> =\n  | WritablePutBatch<K, V>\n  | WritableDelBatch<K, V>;\n\nexport interface WritablePutBatch<K = any, V = any> {\n  readonly type: 'put';\n  key: K;\n  value: V;\n}\n\nexport interface WritableDelBatch<K = any, V = any> {\n  readonly type: 'del';\n  key: K;\n}\n\ninterface SublevelOptions {\n  separator?: string;\n}\n\ninterface OptionsWrapper<K extends Bytes> {\n  gt: (x: K) => K;\n  lt: (x: K) => K;\n}\n\ntype ALD<K> = AbstractLevelDOWN<K, any>;\n\nclass Sublevel<V, K extends Bytes> implements WrappingHandler<V, K> {\n  readonly type = 'sublevel';\n  prefix: string;\n  _wrapper: OptionsWrapper<K>;\n\n  constructor(prefix: string = '', opts: SublevelOptions = {}) {\n    this.prefix = buildPrefix(prefix, opts.separator);\n    this._wrapper = buildWrapper<K>(() => this.prefix);\n  }\n\n  down(db: ALD<K>): ALD<K> | undefined {\n    const subdb = down(db, this.type);\n    if (subdb && subdb.prefix) {\n      this.prefix = subdb.prefix + this.prefix;\n\n      return down(subdb.db);\n    }\n\n    return down(db);\n  }\n\n  get(\n    db: ALD<K>,\n    key: K,\n    options: AbstractGetOptions,\n    cb: ErrorValueCallback<V>\n  ) {\n    db.get(concat(this.prefix, key), options, cb);\n  }\n\n  put(\n    db: ALD<K>,\n    key: K,\n    value: V,\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ) {\n    db.put(concat(this.prefix, key), value, options, cb);\n  }\n\n  del(db: ALD<K>, key: K, options: AbstractOptions, cb: ErrorCallback) {\n    db.del(concat(this.prefix, key), options, cb);\n  }\n\n  batch(\n    db: ALD<K>,\n    operations: WritableBatch<K, V>[],\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ) {\n    // No need to make a copy of the array, abstract-leveldown does that\n    for (var i = 0; i < operations.length; i++) {\n      operations[i].key = concat(this.prefix, operations[i].key);\n    }\n\n    db.batch(operations, options, cb);\n  }\n\n  iterator(\n    src: ALD<K>,\n    leveldown: ALD<K>,\n    options: AbstractIteratorOptions<K>\n  ): AbstractIterator<K, V> {\n    const xopts = addRestOptions(\n      wrap(fixRange(options), this._wrapper),\n      options\n    );\n    return new SubIterator(src, leveldown.iterator(xopts), this.prefix);\n  }\n}\n\nclass SubIterator<V, K extends Bytes> extends AbstractIterator<K, V> {\n  iterator: AbstractIterator<K, V>;\n  prefix: string;\n  constructor(\n    db: AbstractLevelDOWN<K, V>,\n    ite: AbstractIterator<K, V>,\n    prefix: string\n  ) {\n    super(db);\n\n    this.iterator = ite;\n    this.prefix = prefix;\n  }\n\n  _next(cb: ErrorKeyValueCallback<K, V>) {\n    this.iterator.next((err, key, value) => {\n      if (err) return (cb as ErrorCallback)(err);\n      if (key) key = key.slice(this.prefix.length) as K;\n      cb(err, key, value);\n    });\n  }\n  _seek(key: K) {\n    this.iterator.seek(concat(this.prefix, key));\n  }\n  _end(cb: ErrorCallback) {\n    this.iterator.end(cb);\n  }\n}\nfunction compatibleConstructor<V, K extends Bytes = string>(\n  db: LUP<K>,\n  prefix: string = '',\n  options: SublevelOptions = {}\n): AbstractLevelDOWN<K, V> {\n  return new WrappedAbstract(db, new Sublevel(prefix, options));\n}\n\nfunction fixRange<K extends Bytes>(\n  opts: AbstractIteratorOptions<K>\n): AbstractIteratorOptions<K> {\n  return !opts.reverse || (!opts.end && !opts.start)\n    ? opts\n    : { start: opts.end, end: opts.start };\n}\n\nfunction addRestOptions<K extends Bytes>(\n  target: AbstractIteratorOptions<K>,\n  opts: AbstractIteratorOptions<K>\n): AbstractIteratorOptions<K> {\n  for (const k in opts) {\n    if (Object.hasOwnProperty.call(opts, k) && !isRangeOption(k)) {\n      (target as any)[k] = opts[k];\n    }\n  }\n\n  return target;\n}\n\nconst rangeOptions = 'start end gt gte lt lte'.split(' ');\nfunction isRangeOption(k: string) {\n  return rangeOptions.indexOf(k) !== -1;\n}\n\nfunction buildPrefix(prefix: string, separator: string = '!'): string {\n  if (prefix[0] === separator) prefix = prefix.slice(1);\n  if (prefix[prefix.length - 1] === separator) prefix = prefix.slice(0, -1);\n\n  return separator + prefix + separator;\n}\n\nconst ENDbuf = Buffer.from([0xff]);\nconst ENDstr = '\\xff';\nfunction buildWrapper<K extends Bytes>(\n  prefix: () => string\n): OptionsWrapper<K> {\n  return {\n    gt: function(x: K) {\n      return concat<K>(prefix(), x || '', true);\n    },\n    lt: function(x: K) {\n      if (Buffer.isBuffer(x)) {\n        if (!x.length) {\n          x = ENDbuf as K;\n        }\n\n        return concat<K>(prefix(), x);\n      }\n\n      return concat<K>(prefix(), x || ENDstr);\n    },\n  };\n}\n\nfunction concat<K extends Bytes>(\n  prefix: string,\n  key: Bytes,\n  force: boolean = false\n): K {\n  if (!(force || key.length)) {\n    return key as K;\n  }\n\n  if (typeof key === 'string') {\n    return (prefix + key) as K;\n  } else if (Buffer.isBuffer(key)) {\n    return Buffer.concat([Buffer.from(prefix), key]) as K;\n  }\n\n  throw new Error('key must be a string or a buffer');\n}\n\nfunction down<DB extends AbstractLevelDOWN>(\n  db: DB,\n  type?: string\n): DB | undefined {\n  if (typeof db.down === 'function') return db.down(type);\n  if (type && db.type === type) return db;\n  if (isLooseAbstract(db.db)) return down(db.db, type);\n  if (isLooseAbstract(db._db)) return down(db._db, type);\n  return type ? undefined : db;\n}\n\nfunction isLooseAbstract(db: any) {\n  if (!db || typeof db !== 'object') {\n    return false;\n  }\n  return typeof db._batch === 'function' && typeof db._iterator === 'function';\n}\n\nexport default compatibleConstructor;\n","import { Bytes } from 'leveldown';\nimport {\n  AbstractLevelDOWN,\n  ErrorCallback,\n  AbstractOptions,\n  AbstractBatch,\n} from 'abstract-leveldown';\nimport { WrappedAbstract, WrappingHandler, LUP } from './wrap_abstract';\n\ntype ALD<K> = AbstractLevelDOWN<K, any>;\n\nclass Batching<V, K extends Bytes> implements WrappingHandler<V, K> {\n  readonly type = 'batch';\n  base: LUP<K>;\n  operations: AbstractBatch<K, V>[];\n\n  constructor(base: LUP<K>) {\n    this.base = base;\n    this.operations = [];\n  }\n\n  async write() {\n    if (this.operations.length === 0) return;\n\n    const ops = this.operations;\n    this.operations = [];\n\n    await this.base.batch(ops);\n  }\n\n  put(\n    db: ALD<K>,\n    key: K,\n    value: V,\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ) {\n    if (options && options.writeBatch === true) {\n      db.put(key, value, options, cb);\n    } else {\n      this.operations.push({ type: 'put', key, value });\n      if (cb) process.nextTick(cb);\n    }\n  }\n\n  del(db: ALD<K>, key: K, options: AbstractOptions, cb: ErrorCallback) {\n    if (options && options.writeBatch === true) {\n      db.del(key, options, cb);\n    } else {\n      this.operations.push({ type: 'del', key });\n      if (cb) process.nextTick(cb);\n    }\n  }\n\n  batch(\n    db: ALD<K>,\n    ops: AbstractBatch<K, V>[],\n    options: AbstractOptions,\n    cb: ErrorCallback\n  ) {\n    if (options && options.writeBatch === true) {\n      db.batch(ops, options, cb);\n    } else {\n      ops.forEach(o => this.operations.push(o));\n      if (cb) process.nextTick(cb);\n    }\n  }\n}\n\nfunction compatibleConstructor<V, K extends Bytes = string>(db: LUP<K>) {\n  const batcher = new Batching<V, K>(db);\n\n  return {\n    db: new WrappedAbstract<V, K>(db, batcher) as AbstractLevelDOWN<K, V>,\n    write: () => batcher.write(),\n  };\n}\n\nexport default compatibleConstructor;\n"],"sourceRoot":""}